/**
 * EXPLOIT TEST: Reentrancy Risk (Anchor)
 * 
 * This test demonstrates the logic flow of the reentrancy vulnerability.
 * 
 * Vulnerability: The `withdraw` function performs a CPI (SOL transfer) to the user
 * BEFORE updating the vault's internal balance.
 * 
 * Exploit Scenario (Theoretical without malicious program):
 * 1. Attacker deploys a malicious program that accepts SOL transfers.
 * 2. Attacker calls `withdraw`.
 * 3. The vulnerable program transfers SOL to the malicious program.
 * 4. The malicious program's fallback function is triggered.
 * 5. The fallback function calls `withdraw` AGAIN.
 * 6. Since the vulnerable program hasn't updated `vault.balance` yet, the check passes.
 * 7. Attacker drains funds recursively.
 * 
 * NOTE: To fully execute this exploit, we would need to deploy a malicious program.
 * This test demonstrates the vulnerable function call succeeds, and highlights
 * the dangerous pattern in the code.
 */

import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";
import { BN } from "bn.js";

describe("04-reentrancy-risk: Anchor Exploit", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const PROGRAM_ID = new PublicKey("9vK8vvwYXN2vVrxKPPzVqWKFQvXYrJJMWJWWNnLqFqBZ");

    it("Executes the vulnerable withdraw function (CPI before State Update)", async () => {
        console.log("\nüéØ EXPLOIT: Reentrancy Risk (Anchor)\n");

        const idl = await Program.fetchIdl(PROGRAM_ID, provider);
        if (!idl) {
            throw new Error("IDL not found. Make sure the program is deployed.");
        }
        const program = new Program(idl, PROGRAM_ID, provider);

        const user = Keypair.generate();
        console.log("üë§ User:", user.publicKey.toBase58());

        // Airdrop SOL
        const airdropSig = await provider.connection.requestAirdrop(
            user.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropSig);

        // Derive vault PDA
        const [vaultPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), user.publicKey.toBuffer()],
            PROGRAM_ID
        );

        // Step 1: Initialize
        console.log("\nüìù Step 1: Initialize vault...");
        await program.methods
            .initialize()
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([user])
            .rpc();

        // Step 2: Deposit 1 SOL
        const depositAmount = new BN(1 * LAMPORTS_PER_SOL);
        console.log(`\nüí∞ Step 2: Deposit 1 SOL...`);
        await program.methods
            .deposit(depositAmount)
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
                systemProgram: SystemProgram.programId,
            })
            .signers([user])
            .rpc();

        // Step 3: Withdraw 0.5 SOL
        // In the vulnerable code, the Transfer (CPI) happens BEFORE balance update.
        const withdrawAmount = new BN(0.5 * LAMPORTS_PER_SOL);
        console.log(`\nüö® Step 3: Withdraw 0.5 SOL...`);
        console.log("‚ö†Ô∏è  Vulnerability: This function performs CPI (Transfer) before updating balance!");
        console.log("‚ö†Ô∏è  A malicious 'user' program could call back into withdraw() here.");

        await program.methods
            .withdraw(withdrawAmount)
            .accounts({
                user: user.publicKey,
                vault: vaultPda,
            })
            .signers([user])
            .rpc();

        const vaultAccount = await program.account["vault"].fetch(vaultPda);
        console.log(`\n‚úÖ Withdrawal successful (User wallet used, so no reentrancy occurred)`);
        console.log(`üè¶ Vault internal balance: ${vaultAccount.balance.toString()}`);

        console.log("\n‚ö†Ô∏è  DEMONSTRATION COMPLETE: Code execution flow confirmed vulnerable pattern.");
    });
});
